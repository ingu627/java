## 객체 지향 설계 5원칙

- **SOLID**는 아래 다섯 가지 원칙의 앞 머리 알파벳을 따서 부르는 이름이다.
  - **SRP(Single Responsibility Principle)**: 단일 책임 원칙
  - **LSP(Liskov Substitution Principle)**: 리스코프 치환 원칙
  - **ISP(Interface Segregation Principle)**: 인터페이스 분리 원칙
  - **DIP(Dependency Inversion Principle)**: 의존 역전 원칙

> 응집도는 높이고(High Cohesion), 결합도는 납추라(Loose Coupling)는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다.

- **결합도(coupling)**: 모듈(클래스) 간의 상호 의존 정도
  - 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
  - 결합도 수준: 데이터, 스탬프, 컨트롤, 외부, 공유, 내용 
- **응집도(cohesion)**: 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
  - 응집도 수준: 기능, 순차, 통신, 절차, 시간, 논리, 우연

<br>

- SOLID는 객체 지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리. 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용된다.ㄴ
- SOLID를 잘 녹여낸 소프트웨어는 그렇지 않은 소프트웨어에 비해 상대적으로 이해하기 쉽고, 리팩터링과 유지보수가 수월할 뿐만 아니라 논리적으로 정연하다.

<br>

### SRP - 단일 책임 원칙 

- "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다."
- 책에서는 남자 클래스에 단일 책임 원칙을 적용해 여러 개의 클래스로 분리하는 예시를 보여준다.
- 메서드가 단일 책임 원칙을 지키지 않을 경우는 대표적으로 분기 처리를 위한 if문을 사용할 때이다.

<br>

### OCP - 개방 폐쇄 원칙

- "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다"
  - "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."
- 예를 들어, 자동차와 운전자의 관계를 생각해본다.
  - 운전자는 차량에 따라 운전하던 습관을 바꿔야 되는가?
  - 스틱 차량에서 오토 차량으로 바꿨다고 해서 운전자가 운전에 영향을 받아야만 하는가?
  - 상위 클래스 또는 인터페이스 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다.
  - 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.
- 또 다른 좋은 예시는 JDBC이다. 
  - MySQL이나 MS-SQL로 교체할 때 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 변화에 영향을 받지 않는다.
  - 데이터베이스 주변의 변화에는 닫혀 있고 데이터베이스를 교체한다는 것은 데이터베이스 자신의 확장에는 열려 있다는 것이다.
- 자바에도 개방 폐쇄 원칙이 적용돼 있다.
  - 각 운영체제별 JVM과 목적 파일(.class)이 있기때문에 개발자는 운영체제와 상관없이 코드만 작성하면 된다.
  - 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려 있는 구조가 된다. 
  - 개발자의 소스코드와 운영체제별 JVM 사이에는 목적 파일(.class)이라고 하는 완충 장치가 있다. 

<br>

### LSP - 리스포크 치환 원칙

- "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다."
  - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- 객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다.
  - 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
  - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
- 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 된다.

<br>

### ISP - 인터페이스 분리 원칙

- "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다."
- 앞서 단일 책임 원칙에서 남자 클래스를 단일 책임을 갖는 클래스로 나누었다.
- 인터페이스 분리를 통해 남자 클래스를 토막 내는 것이 아니라 다중 인격화시켜 각 역할을 각 인터페이스로 제한시킨다. 
- 결과적으로 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
- 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
- "상속 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다."

> 인터페이스는 그 역할에 충실한 최소한의 기능만 공개한다.

<br>

### DIP - 의존 역전 원칙 

- "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
- "추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
- "자주 변경되는 구체(Concrete) 클래스에 의존하지 마라"
- 예를 들어 자동차는 한 번 사면 몇 년은 타야 하는데 스노우타이어는 계절이 바뀌면 일반 타이어로 교체해야 한다.
  - 위와 같은 경우 자동차가 구체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어가 변경돼도 자동차는 그 영향을 받지 않게 된다.

> - 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.
<br>
> - 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 항위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 의존 역전 원칙이다. 