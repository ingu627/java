## 3. 자바와 객체 지향

- 객체 지향은 현실 세계를 반영한다.
- 기존의 구조적 프로그래밍 언어에서 가장 중요한 것은 "함수"
  - **함수**는 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 것이다.
  - Divide and Conquer
  - 몇 천, 몇 만 라인의 명령어를 논리적인 단위로 나누어 블록화해서 작성하자는 것이다.
  - 함수의 목적 : (1) 중복 제거 (2) 논리의 분할
- 객체 지향은 현실세계를 인지하는 방식으로 프로그램을 만들자는 것이다.
- 사물을 하나하나 이해하기보다는 사물을 **분류(class)**해서 이해하는 것

<br> 

### 캡! 상추다

- **캡** - 캡슐화(Encapsulation): 정보 은닉(Information hiding)
- **상** - 상속(Inheritance): 재사용
- **추** - 추상화(Abstraction): 모델링
- **다** - 다형성(Polymorphism): 사용 편의 

<br>

- **클래스**: 분류에 대한 개념
- **객체**: 실체 

<br>

### 추상화: 모델링

- **추상**: (사전적 의미) 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용
- **추상화**: 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것 
- **객체(object)**: 세상에 존재하는 유일무이한 사물
  - = 클래스의 인스턴스(instance)
- **클래스(class)**: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
  - 사람이라는 클래스를 설계한다면, 사람 클래스를 만들기 위해 주변에서 보이는 실체들, 즉 사람 객체들을 관찰해서 사람 객체들이 가진 공통된 특성을 찾게 된다.
- `사람 홍길동 = new 사람();` : 사람이라는 클래스(분류)를 이용해 유일무이하고 새로운 하나의 사람(객체)을 만들어 홍길동(객체 참조 변수)이라는 이름을 지어준 것이다.
- 또한 애플리케이션 경계라는 개념도 나오는데, 이를 **컨텍스트(context)**라고 부르기도 한다.
  - 이를 알기 위해서는 "내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?"라고 질문을 던져보면 된다. 
- 다시 추상화의 개념으로 돌아와 재정의한다면, 
  - **추상화**: 구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링 
- **모델**: 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 
  - 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다. 

> 자바는 객체 지향의 추상화를 class 키워드를 통해 지원하고 있다.

<br>

- `클래스 객체_참조_변수 = new 클래스();`
  - 클래스 : 객체_참조_변수의 자료형(Type)
  - 객체_참조_변수 : 생성된 객체를 참조할 수 있는 변수 
  - = : 할당문 
  - new : 새로운 
  - 클래스 : 만들고자 하는 객체의 분류
  - `()`: 메서드 
  - => 정리: 새로운 객체를 하나 생성해 그 객체의 주소값(포인터)을 객체 참조 변수에 할당

<br>

- 추상화의 결과는 설계자마다 다를 수 있다.
- 추상화의 결과물은 모델이다.
- 모델은 자바 언어에서 클래스로 표현된다.
- 클래스 모델을 표현하는 국제 표준 표기법은 UML 클래스 다이어그램이다.


<br>

- **스태틱(static)**은 "고정된"이라는 뜻을 가지고 있다.
  - 스태틱 영역에 올라간 정보는 main() 메서드가 시작되기 전에 올라가서 main() 메서드가 종료된 후에 내려올 정도로 스태틱 영역에 단단히 고정돼 있다.
- **스택(stack)**은 FIFO, LIFO, FILO 같은 자료구조를 생각하면 쉽다.
- **힙(heap)**은 대용량 자료를 저장할 수 있도록 메모리를 사용하는 방식이다.

<br>

- **클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버**
- static 키워드가 붙은 속성은 클래스 멤버 속성, static이 안 붙은 속성은 객체 멤버 속성이라 한다.
  - main() 메서드는 static이 항상 붙어 있는데 이게 클래스 멤버 메서드이기 때문이다.
- 클래스 멤버 = static 멤버 = 정적 멤버
- 객체 멤버 = 인스턴스 멤버

<br>

### 상속: 재사용 + 확장 

- 객체 지향의 상속의 예로 분류도가 있다.
  - 계층도, 조직도는 잘못된 예이다.
- 객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.
  - 부모 클래스 - 자식 클래스 (X)
  - 상위 클래스 - 하위 클래스 (O)
  - 슈퍼 클래스 - 서브 클래스 (O)
- 상속 관계에서 반드시 만족해야 할 문장이 있다.
  - `하위 클래스는 상위 클래스다`

<br>

- **is a** : **객체 is a 클래스**
- 상속 관계의 더 명확한 영어 표현은 **is kind of** 관계이다.
  - 예) 펭귄 is a kind of 조류 : 펭귄은 조류의 한 분류다.

<br>

- **Summary**
  1. 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
  2. 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
  3. 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

<br>

### 상속과 인터페이스 

- **인터페이스**: 구현 클래스 **is able to** 인터페이스
  - 해석: 구현 클래스는 인터페이스할 수 있다.
  - 예제: 고래는 헤엄칠 수 있다.
  - **is able to**: 무엇을 할 수 있는 
    - Serializable 인터페이스: 직렬화할 수 있는
    - Cloneable 인터페이스: 복제할 수 있는
    - Comparable 인터페이스: 비교할 수 있는
    - Runnable 인터페이스: 실행할 수 있는
- 즉, 상위 클래스는 하위 클래스에게 특성(속성과 메서드)을 상속해 주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제하게 된다.
  - 상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다는 결론에 도달할 수 있다.

<br>

### 다형성: 사용편의성 

- **다형성**: 오버라이딩(overriding), 오버로딩(overloading)
  - ride: 올라타다 (위로 쌓기)
  - load: 적재하다 (옆으로 나란히)
- 이해하기 위해 예를 들어 인공위성에서 내려 본다면, 오버라이딩(올라타기)된 경우는 맨 위에 올라탄 존재만 보인다. 오버로딩(적재하기) 된 경우는 옆으로 적재된 모든 적재물이 다 보인다.
  - 오버라이딩은 맨 위에 올라탄 놈만 보인다. 
  - 오버로딩된 경우는 옆으로 적재된 모든 적재물이 다 보인다.
- **오버라이딩** - 재정의 : 상위클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트
- **오러로딩** - 중복정의 : 같은 메서드 이름, 다른 인자 리스트로 다수의 메서드를 중복 정의

> 단, 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다.

<br>

### 캡슐화: 정보 은닉

- UML 표기법에서 `-` 표시는 private 접근 제어자를, `~` 표시는 [default] 접근 제어자를, `#` 표시는 protected 접근 제어자를, `+` 표시는 public 접근 제어자를 나타낸다.
  - 속성이나 메서드 아래에 `_`(밑줄)을 사용한 경우는 정적 멤버를 나타낸다.

- **public**: 모두가 접근 가능 
- **protected**: 상속 / 같은 패키지 내의 클래스에서 접근 가능 
- **default**: 같은 패키지 내의 클래스에서 접근 가능
- **private**: 본인만 접근 가능

<br>

- **주의사항**
  1. 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
  2. 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
     - 일관된 형식으로 접근하기 위해서
     - static 멤버는 예1. 사람 클래스의 인구 예2. 고양이의 다리 개수 같은 경우에 쓴다.
       - 사람.인구, 고양이.다리개수 형식으로 접근하는 것이 좋다.
       - 즉, 정적 멤버에 접근할 때는 객체참조변수명.정적멤버 형식으로 접근하기보다는 클래스명.정적멤버 형식으로 접근한다.

<br>

### 참조 변수의 복사 

- **Call By Value(값에 의한 호출)**에 의해 그 값이 복사되며 두 개의 변수는 서로에게 영향을 주지 않는다.
- 반면 **Call By Reference(참조에 의한 호출)** 또는 **Call By Address(주소에 의한 호출)**은 영향이 있다.
- 차이점은 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하지만 객체 참조 변수는 저장하고 있는 값을 주소로 해석한다는 차이가 있다.