## 예외 처리

- **예외**는 프로그램 실행 중에 발생하는 비정상적인 상황이다. 
- 자바는 실행 중에 발생할 수 있는 비정상적인 상황을 다음 두 가지로 구분한다.
  1. **에러(Error)**: 메모리가 부족하거나 스택이 가득 찬 정도의 치명적인 상황이며 복구 불가능하여 더 이상 실행을 계속할 수 없다. 
  2. **예외(Exception)**: 일고자 하는 파일이 없거나 계산식을 수행할 수 없는 정도의 경미한 오류이며, 오류 조건을 제거하면 계속 실행할 수 있다. 
- 즉, 예외는 발생 조건을 미리 걸러낸다거나 발생한 후에 조치할 수 있다. 
- 안정적인 프로그램은 어떠한 상황에서도 계속 실행할 수 있도록 발생 가능한 모든 예외를 적절히 처리해야 한다.
- 예외 블록의 기본 형식은 다음과 같다.
  1. 예외 발생 가능성이 있는 코드를 try 블록으로 감싼다.
  2. 실행 중에 예외가 발생하면 catch 블록으로 점프하여 어떤 예외가 발생했는지 예외 객체가 전달된다.
  3. finally 블록에는 예외 발생과 상관없이 항상 실행할 코드를 작성하는데 필요 없을 시 생략한다.
     a. 주로 리소스 해제 코드를 작성하는데 가비지 컬렉터가 메모리를 관리하므로 finally 블록을 사용하는 경우는 흔하지 않다.

```java
try {
    예외가 발생할 만한 코드 
        }
catch (예외 객체){
    예외 처리
        }
finally {
    리소스 해제
        }
```

<br>

- 예외 발생 전에 선제적으로 조건을 점검하여 예외를 일으키는 코드를 실행하지 않도록 해야 하며 예외 발생 지점에서 즉시 점검해야 한다. 
- 예외처리를 통해 일반적인 조건문과 예외 처리 구문이 확실하게 분리되어 코드의 구조가 향상되고 유지 보수에도 유리하다.

<br>

### 1. 예외 객체 

- 자바의 예외 클래스 계층은 다음과 같다. 

<img src="img/예외계층구조.png">

<br>

- 다음 메소드는 예외가 발생한 원인을 문자열로 리턴한다. 

```java
String getMessage()
```

> 참고 파일: `exmessage.java`

<br>

### 2. 여러 개의 예외 처리 

- 여러 가지 예외가 동시에 발생할 수 있는 상황이라면 예외의 종류에 따라 여러 개의 catch 블록을 나열한다.
  - 참고: `MultiCatch.java`
- 예외 객체 간에도 다형성이 성립되어 부모 타입의 예외 객체가 자식 타입의 예외 객체를 받을 수 있다. 
- `ArithmeticException`이나 `ArrayIndexOutOfBoundsException`은 `RuntimeException`의 자식이므로 두 예외를 하나의 catch 블록으로 처리해도 된다.
  - 참고 파일: `Polyex.java`
- 예외 블록이 catch 문을 찾는 방법은 switch case 문과 비슷하다.
  - 그래서 catch 블록은 가급적 위쪽에 특수한 예외를 배치하고 뒤로 갈수록 일반적인 예외를 처리한다.

<br>

### 3. 메소드 간의 예외 전달 

- 예외 처리 구문은 조건문과 달리 메소드 호출 간에도 처리된다.
- 메소드 호출 단계는 스택에 기록되는데 `pirintStackTrace` 메소드는 이 정보를 읽어 예외 발생 시의 호출 스택 상태를 출력한다.

<br>

### 4. 사용자 정의 예외 

- throw 구문으로 예외 객체를 생성하여 던지며 예외 객체의 생성자로 설명 문자열을 제공한다.
- 즉, 메소드가 예외를 던지는 것은 직접 처리하지 않고 상위의 호출원에게 예외에 대한 처리를 부탁하는 것이다. 
- `Throw3.java`에서 printScore 메소드는 name이 null일 경우 자신이 직접 처리하지 않는다.
  - 대신 예외 객체를 생성하여 throw 구문으로 던져 호출원에게 어떤 예외가 발생했는지 알리고 처리를 위임한다.