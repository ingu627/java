## 중첩 클래스

- **중첩 클래스**는 클래스 안에 클래스를 선언하는 것이다. 
- 관련 있는 클래스를 중첩하여 하나로 선언하면 다음과 같은 이점이 있다.
  1. 외부 클래스가 필요한 정보를 다 포함하여 재사용성이 향상된다.
  2. 다른 곳에서 사용하지 않는 클래스를 숨겨 보안성과 안정성이 향상된다.
  3. 연관 있는 클래스를 하나로 묶어 긴밀한 관계가 되며 서로의 멤버를 자유롭게 참조할 수 있다.
- 메소드는 같은 클래스 소속의 필드를 자유롭게 읽고 쓸 수 있다. 

<br>

### 1. Inner 클래스 객체 생성

- 내부 클래스도 하나의 타입이므로 외부에서 객체를 생성할 수 있다. 
- 단, 홀로 생성할 수 없으며 반드시 외부 객체로부터 생성해야 한다.
- 다음은 외부에서 내부 클래스의 객체를 생성할 때의 구문이다.

```java
Outer.Inner 변수명 = 외부객체.new Inner(생성자 인수)
```

<br>

### 2. 중첩 상태에서의 this

- **this** 키워드는 메소드를 호출하는 객체를 나타내며 메소드 안에서 this는 자기 자신이다.
- 외부 클래스의 객체를 지칭하고 싶을 땐 다음 형식을 사용한다.
  - 즉, 중첩 상태에서는 this도 정확한 소속을 밝혀야 한다. 

```java
외부클래스.this
```

<br>

### 3. Static inner 클래스

- 내부 클래스는 외부 클래스와 밀접한 관계를 가지며 외부 클래스의 멤버를 자유롭게 액세스할 수 있다.
  - 즉, 일반 필드와 같다. 
- 이에 비해 static inner 클래스는 소속만 외부 클래스 안에 있을 뿐 일반적인 클래스와 같아 외부 클래스의 멤버는 참조할 수 없다.

<br>

- inner 클래스와 static inner 클래스의 차이점은 메소드의 경우와 같다.
- 일반 멤버는 static 멤버를 읽을 수 있지만, static 멤버는 static 멤버만 액세스할 수 있다. 

<br>

### 4. Local inner 클래스

- 지역 내부 클래스는 매소드 내에서 지역적으로 선언하는 클래스이다. 
- 마치 지역 변수를 선언하듯이 메소드 안에서 임시 클래스를 선언하여 사용할 수 있다.

<br>

### 5. Anonymous inner 클래스 

- 기존에는 메소드의 동작을 수정하기 위해 상속을 받고 재정의한 후 객체까지 만드는 것이 번거로운데, 이 과정을 간편하게 처리하기 위해 익명 클래스를 사용한다.
- 다음은 상속과 메소드 재정의, 객체 생성까지 한 번에 처리하는 문법이다.

```java
Super 객체명 = new Super() {
  재정의할 메소드 정의
}
```

- **Anonymous inner** 클래스는 이처럼 익명의 클래스를 선언하기 때문에 객체를 딱 하나만 생성할 수 있다. 
- 메소드를 재정의한 객체 하나만 필요할 때 가장 편리한 방법이다.
- 익명 클래스는 상속과 재정의, 객체 생성을 위해 사용하는 일회용 클래스이다.
- 따라서 여러 개의 객체를 생성한다거나 부모가 여럿이라면 익명의 클래스를 사용해서는 안 되며 일반 문법을 사용해야 한다.
